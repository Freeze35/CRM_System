Проект создан с целью предоставления упрощённую версию CRM (Customer Relationship Management) (В разработке)

Документация внутренней архитектуры виузализация на figma
[CRM_DIAGRAM](https://www.figma.com/board/W6NXFIPn5LFjR666mMIfRY/%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82-CRM-System?node-id=0-1&t=HuxqfT14xiZvZ4yY-0)

CRM-система на основе микросервисной архитектуры

### Обзор

Данный проект представляет собой масштабируемую CRM-систему (систему управления взаимоотношениями с клиентами), построенную на основе микросервисной архитектуры. В основе системы лежит шлюз на базе NGINX, выполняющий функции обратного прокси, балансировщика нагрузки и модуля авторизации. Каждый микросервис отвечает за определённую функциональность, включая авторизацию, управление чатами, отслеживание таймеров, отправку электронных писем, логирование и кэширование на базе Redis. Все сервисы взаимодействуют через gRPC по протоколу HTTPS. Архитектура обеспечивает модульность, безопасность и высокую доступность, а доступ к сервисам защищён с помощью JWT-авторизации.

### Архитектура

Система построена на принципах микросервисной архитектуры, где NGINX выступает центральным шлюзом, маршрутизирующим запросы к соответствующим backend-сервисам. Основные компоненты:

### Шлюз NGINX:

Выполняет функции обратного прокси и балансировщика нагрузки, направляя HTTP- и gRPC-запросы к микросервисам.

Реализует авторизацию на основе JWT с использованием модуля ngx_http_auth_jwt_module.

Обеспечивает HTTPS с поддержкой TLS 1.2/1.3 и проверкой клиентских сертификатов.

Обрабатывает ошибки (например, 400, 401, 502) с возвратом JSON-сообщений.

Поддерживает перенаправление на обновление токена для неавторизованных запросов.

---

## Микросервисы:

- ### [Сервис авторизации](#auth) (auth:50055, auth:50056): Отвечает за регистрацию пользователей, вход в систему и выдачу токенов. Поддерживает gRPC-эндпоинты (/protobuff.AuthService) и HTTP (/auth), с отключённой JWT-авторизацией для /auth/login и /auth/register.

- ### [Сервис чатов](#chats) (chats:50095, dbservice:8081): Управляет созданием чатов и хранением сообщений через HTTP (/chats) и gRPC (/protobuff.dbChatService).

- ### [Сервис таймеров](#timers) (timer:50020, dbservice:8081): Отслеживает таймеры пользователей с операциями запуска, остановки, изменения и добавления через HTTP (/timer) и gRPC (/protobuff.dbTimerService).

- ### [Сервис администрирования](#admin_control) (admin_control:50070, dbservice:8081): Предоставляет функции администрирования через HTTP (/admin) и gRPC (/protobuff.dbAdminService).

- ### [Сервис отправки писем](#mails) (email-service:50051): Отправляет уведомления по электронной почте через gRPC (/protobuff.EmailService).

- ### [Сервис логирования](#logs) (logs:50150): Сохраняет системные логи через gRPC (/protobuff.LogsService).

- ### [Сервис Redis](#redis) (redis:50060): Обеспечивает кэширование и получение данных через gRPC (/protobuff.RedisService).

- ### [Сервис базы данных](#dbsrevice) (dbservice:8081): Централизованный gRPC-сервис для операций с базой данных, поддерживающий несколько сервисов (dbAuthService, dbService, dbChatService, dbTimerService).

---

## Конфигурация NGINX

NGINX настроен для обработки как HTTP-, так и gRPC-трафика, с акцентом на безопасность и авторизацию:

TLS/SSL:

Поддерживает TLS 1.2 и 1.3 с использованием надёжных шифров (например, ECDHE-ECDSA-AES256-GCM-SHA384).

Использует серверные сертификаты (server.pem, server.key) и проверку клиентских сертификатов (ca.crt).

Применяет HTTP Strict Transport Security (HSTS) с максимальным сроком действия 6 месяцев.

Перенаправляет HTTP (порт 80) на HTTPS (порт 443).

### JWT-авторизация:

Включена с использованием модуля ngx_http_auth_jwt_module и алгоритма RS256.

Проверяет токены, хранящиеся в cookie (access_token), с использованием публичного ключа (/etc/nginx/opensslkeys/public_key.pem).

### Маршрутизация:

HTTP-запросы для /auth, /admin, /chats, и /timer перенаправляются на соответствующие сервисы через HTTPS.

gRPC-запросы для /protobuff.* (например, AuthService, dbChatService, EmailService) направляются на сервисы через grpcs://.

Поддерживает передачу заголовков (Host, X-Real-IP, X-Forwarded-For, Authorization) для обеспечения прозрачности и безопасности.

Обработка ошибок:

Возвращает JSON-ответы для ошибок 400 ("Некорректный адрес обращения"), 401 ("Проблема с токеном") и 502 ("Пользователь не авторизирован").

Перенаправляет неавторизованные запросы (401) для /admin и /chats на /auth/refresh для обновления токена.

### Функциональность

Система предоставляет следующие ключевые возможности:

- Авторизация и аутентификация: Регистрация и вход пользователей, управление токенами JWT.

- Управление чатами: Создание чатов, отправка и хранение сообщений.

- Отслеживание времени: Запуск, остановка, изменение и добавление таймеров для учёта рабочего времени.

- Администрирование: Управление пользователями и компаниями через административный интерфейс.

- Уведомления: Отправка электронных писем для уведомлений пользователей.

- Логирование: Сохранение системных логов для мониторинга и отладки.

### Сборка и развертывание

Система полностью контейнеризирована с использованием Docker и управляется через Docker Compose. Каждый микросервис собирается из исходного кода на Go (версия 1.23) с использованием многоэтапной сборки.

---

## Docker Compose:

Сервисы:

- db: PostgreSQL 15 с томом db-data (порт 5432).

- auth: Авторизация (порты 50055, 50056).

- admin_control: Администрирование (порт 50070).

- dbservice: База данных (порт 8081).

- timer: Таймеры (порт 50020).

- nginx: Шлюз (порты 80, 443).

- redis: Кэширование (порты 50060, 6379, том redis_data).

- rabbitmq: Очереди сообщений (порты 5672, 15672).

- email-service: Отправка писем (порт 50051).

- chats: Чаты (порт 50095).

- logs: Логирование (порт 50150).

- loki: Хранение логов (порт 3100).

- grafana: Визуализация логов (порт 3000).

Зависимости: Сервисы зависят от db и/или rabbitmq.

Сеть: crm-network (bridge) для взаимодействия.

---

<h2 id="auth"> Сервис авторизации</h2>

Обзор

Микросервис авторизации (auth) является ключевым компонентом CRM-системы, 
построенной на микросервисной архитектуре.  
Он отвечает за регистрацию пользователей, аутентификацию, 
выдачу и обновление JWT-токенов, а также проверку авторизации. Сервис поддерживает как gRPC, 
так и HTTP-протоколы, обеспечивая безопасное взаимодействие с другими сервисами и клиентами через TLS.  
Микросервис контейнеризирован с использованием Docker и интегрирован в систему через NGINX-шлюз, который выполняет функции обратного прокси, балансировщика нагрузки и JWT-аутентификации.

### Функциональность

#### Микросервис предоставляет следующие возможности:

##### Регистрация компании:

Эндпоинт: POST /auth/register

- Принимает JSON с данными компании (NameCompany, Address, Email, Phone, Password).

- Валидирует входные данные (телефон, пароль) с использованием кастомных правил.

- Вызывает gRPC-метод RegisterCompany на dbservice.

- Генерирует access_token и refresh_token, возвращает их в HTTP-only cookies.

##### Вход в систему:

- Эндпоинт: POST /auth/login

- Принимает JSON с данными (Email или Phone, Password).

- Валидирует данные и вызывает gRPC-метод LoginDB на dbservice.

- Возвращает access_token, refresh_token, database, user-id, и company-id в cookies.

##### Обновление токена:

- Эндпоинт: POST /auth/refresh

- Проверяет и обновляет refresh_token, выдавая новый access_token.

- Используется для продления сессии без повторного логина.

##### Проверка авторизации:

- Эндпоинт: POST /auth/check

- Проверяет наличие действительного access_token и возвращает подтверждение.

---

<h2 id="chats">  Микросервис чатов </h2>

Микросервис чатов (chats) является ключевым компонентом CRM-системы, построенной на микросервисной архитектуре.   
Он отвечает за создание чатов, отправку и получение сообщений, а также их асинхронную обработку через RabbitMQ и сохранение в базе данных через gRPC.   
Сервис поддерживает HTTP-протокол для клиентских запросов и интегрирован с NGINX-шлюзом, который выполняет функции обратного прокси, балансировщика нагрузки и JWT-аутентификации.   
Микросервис контейнеризирован с использованием Docker и управляется через Docker Compose.

#### Функциональность

#### Создание чата:

- Эндпоинт: POST /chats/createNewChat

- Принимает JSON с названием чата и списком пользователей (ChatName, UsersId).

- Вызывает gRPC-метод CreateChat на dbservice для создания чата.

- Публикует информацию о чате в RabbitMQ для асинхронного уведомления участников.

#### Отправка сообщения:

- Эндпоинт: POST /chats/{chatID}/sendMessage

- Принимает JSON с содержимым сообщения (Content).

- Асинхронно публикует сообщение в RabbitMQ через обменник (chat_exchange_{chatID}).

- Сохраняет сообщение в базе данных через gRPC-метод SaveMessage.

#### Получение сообщений:

- Эндпоинт: GET /chats/{chatID}/messages

- Подписывается на очередь RabbitMQ для получения сообщений чата.

- Возвращает список сообщений в формате JSON (с таймаутом 5 секунд).

- Примечание: Реализация помечена как TODO для получения сообщений из базы данных, текущая версия полагается на RabbitMQ.

---

<h2 id="timers"> Сервис таймеров</h2>

Он отвечает за управление таймерами, включая их запуск, остановку, изменение, добавление и получение активных таймеров.   
Сервис поддерживает HTTP-протокол для клиентских запросов и взаимодействует с базой данных через gRPC.

#### Функциональность

##### Запуск таймера:

- Эндпоинт: POST /timer/start-timer

- Принимает JSON с описанием таймера (Description).

- Вызывает gRPC-метод StartTimerDB для создания и запуска таймера.

##### Остановка таймера:

- Эндпоинт: POST /timer/end-timer

- Принимает JSON с описанием таймера (Description).

- Вызывает gRPC-метод EndTimerDB для остановки таймера.

##### Получение активного таймера:

- Эндпоинт: GET /timer/get-working-timer

- Возвращает данные активного таймера через gRPC-метод GetWorkingTimerDB.

##### Изменение таймера:

- Эндпоинт: POST /timer/change-timer

- Принимает JSON с идентификатором таймера (TimerId).

- Вызывает gRPC-метод ChangeTimerDB для изменения таймера.

##### Добавление таймера:

- Эндпоинт: POST /timer/add-timer

- Принимает JSON с параметрами таймера (StartTime, EndTime, TimerId, Description).

- Вызывает gRPC-метод AddTimerDB для добавления таймера.

---

<h2 id="admin_control"> Сервис администрирования </h2>

Он отвечает за управление пользователями, в частности, за добавление новых пользователей в компанию с последующей отправкой приветственных писем через сервис электронной почты.

#### Функциональность

##### Добавление пользователей в компанию:

- Эндпоинт: POST /admin/addusers

- Принимает JSON с идентификатором компании (CompanyId) и списком пользователей (Users), включая их email, телефон и роль.

- Валидирует входные данные с использованием библиотеки validator/v10.

- Вызывает gRPC-метод RegisterUsersInCompany на dbservice для регистрации пользователей.

- Асинхронно преобразует данные пользователей с использованием горутин (TransformUsersConcurrently).

- Отправляет приветственные письма каждому пользователю через gRPC-метод SendEmail на email-service, включая логин и пароль.

- Возвращает статистику отправки писем (успешные и неуспешные попытки).

---

<h2 id="mails"> Сервис отправки писем</h2>

Он отвечает за асинхронную отправку электронных писем, используя SMTP-сервер (например, Gmail) для доставки сообщений пользователям.   
Сервис обрабатывает запросы через gRPC и RabbitMQ, обеспечивая масштабируемость и отказоустойчивость.

#### Функциональность

##### Отправка писем через gRPC:

- Метод: SendEmail (/protobuff.EmailService/SendEmail).

- Принимает запрос с адресом получателя (Email), темой (Message) и телом письма (Body).

- Выполняет асинхронную отправку через SMTP-сервер (Gmail) в отдельной горутине.

- Возвращает подтверждение обработки без ожидания завершения отправки.

##### Обработка задач через RabbitMQ:

- Слушает очередь email_tasks с помощью нескольких воркеров (по умолчанию 5).

- Каждый воркер обрабатывает сообщения, извлекая адрес получателя и отправляя письмо через EmailService.SendEmail.

- Поддерживает устойчивую очередь для надежной доставки задач.

---

 <h2 id="dbsrevice"> Сервис базы данных </h2>

Микросервис dbservice является центральным компонентом CRM-системы, построенной на микросервисной архитектуре.   
Он объединяет функциональность авторизации, управления компаниями и пользователями, чатами и таймерами, обеспечивая взаимодействие с базами данных PostgreSQL через gRPC-интерфейсы.   
Сервис обрабатывает операции авторизации, регистрации компаний, управления пользователями, создания и управления чатами, а также учета времени через таймеры.   
Микросервис интегрирован с NGINX-шлюзом для маршрутизации запросов и JWT-аутентификации, использует Redis для кэширования и RabbitMQ для асинхронной обработки задач.    
Контейнеризация с использованием Docker и управление через Docker Compose упрощают развертывание и масштабирование.

#### Функциональность

##### DbAuthService:

- Аутентификация пользователей (LoginDB).

- Регистрация новых компаний (RegisterCompany).

##### DbAdminService:

- Добавление пользователей в компанию (RegisterUsersInCompany)

##### DbChatService

- Создание чатов (CreateChat).

- Добавление пользователей в чаты (AddUsersToChat).

- Сохранение сообщений (SaveMessage).

##### DbTimerService 

- Запуск таймеров (StartTimerDB).

- Остановка таймеров (EndTimerDB).

- Добавление таймеров (AddTimerDB).

- Изменение таймеров (ChangeTimerDB).

- Получение активных таймеров (GetWorkingTimerDB).

Каждая операция использует транзакции для обеспечения целостности данных и кэширование в Redis для оптимизации производительности.

---

<h2 id="logs"> Сервис логирования </h2>

Он отвечает за сбор, обработку и сохранение логов, поступающих от других микросервисов, в систему логирования Loki.
Loki: Принимает HTTP-запросы (POST /loki/api/v1/push) для сохранения логов в формате JSON.

#### Функциональность

##### Сохранение логов через gRPC:

- Метод: SaveLogs (/protobuff.LogsService/SaveLogs).

- Принимает запрос с метаданными (Name, Level, Database, UserID) и сообщением (Message).

- Формирует JSON-пayload для Loki, включая метки (job, level, database, userId) и временную метку (UnixNano).

- Отправляет асинхронный HTTP-запрос (POST) в Loki для сохранения логов.

- Возвращает подтверждение успешного сохранения или ошибку.

---

<h2 id="redis"> Сервис Redis </h2>

Он предоставляет gRPC-интерфейс для взаимодействия с Redis, обеспечивая кэширование данных для оптимизации производительности других микросервисов, таких как dbservice.   
Сервис поддерживает операции сохранения (Save) и получения (Get) данных в Redis с указанием времени жизни ключа.

#### Функциональность

##### Сохранение данных в Redis (Save):

- Сохраняет ключ-значение с указанным временем жизни (TTL).

- Использует SetNX для предотвращения перезаписи существующих ключей.

##### Получение данных из Redis (Get):

- Извлекает значение по указанному ключу.

- Возвращает ошибку, если ключ не найден или истек.

---

### Меры безопасности

Все микросервисы CRM-системы реализуют следующие меры безопасности:

<h3>1. Шифрование соединений (TLS) </h3>

- Описание: Все gRPC-соединения между микросервисами и NGINX-шлюзом используют Transport Layer Security (TLS) для шифрования данных.

#### Реализация:

- Сертификаты TLS загружаются с помощью утилиты utils.LoadTLSCredentials, которая использует ca.crt из директории sslkeys/.

- NGINX настроен для обработки HTTPS-запросов (порт 8443) с использованием сертификатов в /etc/nginx/certs/.

- Каждый микросервис (например, dbservice:8081, redisservice:50051) инициализирует gRPC-сервер с TLS-опцией grpc.Creds(tlsCredentials).

- Цель: Защита от перехвата данных (man-in-the-middle) и обеспечение конфиденциальности.

<h3> 2. Аутентификация с помощью JWT </h3>

- Описание: Внутренний JSON Web Token (JWT) используется для аутентификации gRPC-запросов между микросервисами и NGINX-шлюзом.

#### Реализация:

- NGINX проверяет JWT-токены с использованием публичного ключа (/etc/nginx/opensslkeys/public_key.pem) для всех запросов на /protobuff.* эндпоинты.

- Микросервисы извлекают токен из контекста запроса с помощью utils.ExtractTokenFromContext и проверяют метаданные, такие как database и user-id.

- Пример: В dbservice запросы без валидных метаданных возвращают ошибку codes.Unauthenticated.

- Цель: Гарантия, что только авторизованные клиенты могут выполнять запросы, и предотвращение несанкционированного доступа.

<h3> 3. Управление gRPC-соединениями (Keepalive) </h3>

- Описание: Параметры keepalive обеспечивают стабильность и безопасность gRPC-соединений, предотвращая их зависание или чрезмерное использование ресурсов.

- Все микросервисы построены на внутреннем взаимодействии через микросервисы через gRPC-соединения.

#### Реализация:

- Все микросервисы используют одинаковые параметры keepalive для gRPC-серверов:

- MaxConnectionIdle: 5 минут (закрытие неактивных соединений).

- MaxConnectionAge: 15 минут (максимальный возраст соединения).

- MaxConnectionAgeGrace: 5 минут (дополнительное время для завершения запросов).

- Time: 5 секунд (интервал проверки активности).

- Параметры задаются через grpc.KeepaliveParams в опциях gRPC-сервера.

- Цель: Минимизация риска атак типа "отказ в обслуживании" (DoS) и оптимизация ресурсов.

<h3> 4. Обработка ошибок и логирование </h3>

- Описание: Все ошибки в микросервисах логируются для анализа и обнаружения потенциальных угроз.

#### Реализация:

- Микросервисы используют утилиту utils.SaveLogsError для отправки ошибок в сервис logs через gRPC (/protobuff.LogsService/SaveLogs).

- Пример: В redisservice ошибки Redis (например, redis.Nil или сетевые сбои) возвращаются с HTTP-статусами (404, 500) и передаются в dbservice для логирования.

- Локальное журналирование выполняется через стандартный пакет log для отладки.

- Цель: Обеспечение трассировки ошибок и выявление подозрительной активности.

<h3> 5.  Защита от паники (Recovery Interceptor)</h3>

- Описание: gRPC-серверы защищены от сбоев, вызванных паникой, для обеспечения непрерывной работы.

#### Реализация:

- Все микросервисы используют utils.RecoveryInterceptor как unary интерсептор gRPC-сервера.

- Интерсептор перехватывает панику, логирует ошибку и возвращает клиенту контролируемый ответ (например, codes.Internal).

- Цель: Предотвращение краха сервиса при непредвиденных ошибках.

<h3>6. Изоляция в Docker-сети</h3>

- Описание: Микросервисы изолированы в Docker-сети для ограничения внешнего доступа и защиты внутренних коммуникаций.

#### Реализация:

- Все микросервисы (dbservice, redisservice, postgres, redis) работают в общей Docker-сети crm-network (тип bridge).

- Внешние порты (например, 8443 для NGINX, 8081 для dbservice, 50051 для redisservice) экспонируются только для необходимых взаимодействий.

- Redis настроен с bind 0.0.0.0 и port 6379, но доступен только внутри crm-network.

- Цель: Минимизация поверхности атаки и предотвращение несанкционированного доступа к внутренним сервисам.

<h3>7. Безопасное управление конфигурацией</h3>

- Описание: Конфиденциальные параметры хранятся в .env-файлах и загружаются безопасно.

#### Реализация:

- Каждый микросервис использует github.com/joho/godotenv для загрузки переменных окружения из .env (например, GRPC_PORT, REDIS_PORT, POSTGRES_USER, POSTGRES_PASSWORD).

- Файлы .env исключены из контроля версий (.gitignore) и монтируются в Docker-контейнеры через env_file в Docker Compose.

- Цель: Защита учетных данных и параметров подключения от утечек.

<h3>8. Транзакции и целостность данных</h3>

- Описание: Микросервисы, взаимодействующие с базами данных (например, dbservice), используют транзакции для обеспечения целостности данных.

#### Реализация:

- В dbservice операции, такие как регистрация компании или добавление пользователей, выполняются в SQL-транзакциях с откатом при ошибках.

- Redis в redisservice использует SetNX для атомарного сохранения данных, предотвращая перезапись ключей.

- Цель: Гарантия консистентности данных даже при сбоях.

Рекомендуемая установка make утилиты:  

---

### Запуск Backend на основе Makefile

#### Команда для сборки проекта на основе docker -compose

    make up 

#### Команда для закрытия пула docker-compose без удаления

    make down

**WINDOWS:**
1. Откройте PowerShell от имени администратора:  
Нажмите Win + X и выберите Windows PowerShell (Администратор) или Command Prompt (Администратор).
Разрешите запуск от имени администратора, если появится запрос.
2. Проверьте разрешение на выполнение скриптов:
   Выполните команду, чтобы убедиться, что вы можете запускать скрипты:  
   `Get-ExecutionPolicy`  
Если результат не равен RemoteSigned, установите его следующей командой:
   `Set-ExecutionPolicy RemoteSigned`  
3. Установите Chocolatey:
   Выполните следующую команду для установки Chocolatey:  
   `Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))`  
4. Проверьте установку:  
      После завершения установки в той же сессии PowerShell выполните команду:  
   `choco --version`

Для установки make с помощью Chocolatey выполните следующие шаги:

1. Откройте Windows PowerShell от имени администратора:  
Нажмите Win + X и выберите Windows PowerShell (Администратор).  
2. Установите make с помощью команды Chocolatey:  
   `choco install make`
3. Подтвердите установку, введя Y, если появится запрос.  
4. После завершения установки проверьте, что make успешно установлен, выполнив команду:  
   `make --version`
5. Теперь make должен быть установлен на вашей системе, и вы можете его использовать.

#### PGAdmin
Для проверки работоспособности отдельного микросервиса Postgres рекомендуется:  
    Установить PGAdmin  
    https://www.pgadmin.org/download/pgadmin-4-windows/


    

    